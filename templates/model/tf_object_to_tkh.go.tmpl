{{- define "tkhpropconvert" }}
{{- if .Property.Type.ToTKHAttrWithDiag }}
    {{ .Property.Type.TFToTKHGuard }}{
        val, d := {{ .Property.TFToTKH }}
        diags.Append(d...)
{{- if .Property.Type.ToTKHCustomCode .Type }}
        {{ .Property.Type.ToTKHCustomCode .Type }}
{{- else }}
        tkh.{{ .Property.TKHSetter }}(val)
{{- end }}
{{- if .Property.IsDTypeRequired }}
        if val != nil {
            val.SetAdditionalData(map[string]any{"$type": "{{ .Property.Type.NestedType.APIDiscriminator }}"})
        }
{{- end }}
    }
{{- else }}
    tkh.{{ .Property.TKHSetter }}({{ .Property.TFToTKH }})
{{- end }}
{{- end }}
func tfObjectToTKH{{ .Suffix }}{{ .GoTypeName }}(ctx context.Context, recurse bool, planValues types.Object, configValues types.Object) ({{ .SDKTypeName }}, diag.Diagnostics) {
    var diags diag.Diagnostics
    if planValues.IsNull() || planValues.IsUnknown() || configValues.IsNull() || configValues.IsUnknown() {
        return nil, diags
    }

{{- $type := . }}
{{- if .AllProperties }}
    planAttrValues := planValues.Attributes()
    configAttrValues := configValues.Attributes()
    // avoids the "declared but not used" compiler errors since we don't know beforehand which one we need
    _, _ = planAttrValues, configAttrValues
{{- end }}
    var tkh {{ .SDKTypeName }}
    tkh = {{ .SDKTypeConstructor }}
{{- if .AllProperties }}
{{- range AllDirectProperties . }}
{{- if ne .TFToTKH "" }}
{{- template "tkhpropconvert" ToPropertyWithType . $type }}
{{- end }}
{{- end }}
{{- range AdditionalObjectsProperties . }}
{{- if ne .TFToTKH "" }}
    if recurse {
{{- template "tkhpropconvert" ToPropertyWithType . $type }}
    }
{{- end }}
{{- end }}
{{- end }}
    return tkh, diags
}
